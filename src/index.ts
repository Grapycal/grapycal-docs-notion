import { Client, isFullPage, iteratePaginatedAPI } from "@notionhq/client";
import dotenv from "dotenv";
import fs from "fs-extra";
import { savePage } from "./render";
import { loadConfig } from "./config";
import { getAllContentFiles } from "./file";
import { isFullPageOrDatabase } from "@notionhq/client/build/src/helpers";
import { PageObjectResponse } from "@notionhq/client/build/src/api-endpoints";
import { getFileName, getPageTitle } from "./helpers";

dotenv.config();

async function main() {
  if (process.env.NOTION_TOKEN === "")
    throw Error("The NOTION_TOKEN environment vairable is not set.");
  const config = await loadConfig();
  console.info("[Info] Config loaded ");

  const notion = new Client({
    auth: process.env.NOTION_TOKEN,
  });

  const page_ids: string[] = [];

  console.info("[Info] Start processing mounted databases");
  // process mounted databases
  for (const mount of config.mount.databases) {
    fs.ensureDirSync(`content/${mount.target_folder}`);
    for await (const page of iteratePaginatedAPI(notion.databases.query, {
      database_id: mount.database_id,
    })) {
      if (!isFullPageOrDatabase(page) || page.object !== "page") {
        continue;
      }
      // Skip if the page has a parent page because it will be processed recursively in the parent page
      if (await hasParentPage(page, notion)) {
        continue;
      }
      console.info(`[Info] Start processing page ${page.id}`);
      page_ids.push(page.id);
      page_ids.push(...await savePageRecursive(page, notion, mount.target_folder));
    }
  }

  // process mounted pages
  for (const mount of config.mount.pages) {
    const page = await notion.pages.retrieve({ page_id: mount.page_id });
    if (!isFullPage(page)) continue;
    page_ids.push(...await savePageRecursive(page, notion, mount.target_folder));
  }

  // remove posts that exist locally but not in Notion Database
  const contentFiles = getAllContentFiles("content");
  for (const file of contentFiles) {
    if (!page_ids.includes(file.metadata.id)) {
      fs.removeSync(file.filepath);
    }
  }
}

async function hasParentPage(page: PageObjectResponse, notion: Client) {
  const parentProperty = page.properties['Parent item'];
  if (parentProperty && parentProperty.type === 'relation' && parentProperty.relation.length > 0) {
    return true;
  }
  return false;
}

async function getSubpages(page: PageObjectResponse, notion: Client) {
  const subitemProperty = page.properties['Sub-item'];
  if (subitemProperty && subitemProperty.type === 'relation') {
    const subpages = [];
    for (const item of subitemProperty.relation) {
      const subpage = await notion.pages.retrieve({ page_id: item.id });
      if (isFullPage(subpage)) {
        subpages.push(subpage);
      }
    }
    return subpages;
  }
  return [];
}

/**
 * If the page has a subitems property, save the page and recursively save all subpages
 * @returns the list of page ids that are saved
 */
async function savePageRecursive(
  page: PageObjectResponse,
  notion: Client,
  targetFolder: string
): Promise<string[]> {

  // Get all subpages of the page
  const subpages = await getSubpages(page, notion);
  if (subpages.length === 0){
    // The page has no subpages, save the page into title.md
    await savePage(page, notion, targetFolder);
    return [page.id];
  }
  // The page has subpages, save the page into title/_index.md and save all subpages in title/
  // The folder name must be generated by getFileName so links to the folder work correctly
  const folder = `${targetFolder}/${getFileName(getPageTitle(page), page.id, "")}`;
  fs.ensureDirSync(`content/${folder}`);
  const pageIds = [page.id];
  await savePage(page, notion, folder, "_index.md");
  for (const subpage of subpages) {
    pageIds.push(...await savePageRecursive(subpage, notion, folder));
  }
  return pageIds;
}

main()
  .then(() => process.exit(0))
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
